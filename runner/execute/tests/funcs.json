{
    "twoNumberSum": "function twoNumberSum(array, targetSum) {\n        const hash = {}\n        for(let number of array){\n            if(hash[number]){\n                return number > hash[number] ? [hash[number], number] : [number, hash[number]]\n            }\n            hash[targetSum - number] = number;\n        }\n        return []\n    }\n    twoNumberSum([1,2,3,4,5], 5)\n    ",
    "mergeSort": "function split(wholeArray){\n        const result = [];\n        const midPoint = Math.floor(wholeArray.length / 2);\n        if (wholeArray.length === 0){\n            return undefined;\n        }\n        else if (wholeArray.length === 1){\n            return wholeArray;\n        }\n        else {\n            result.push(wholeArray.slice(0,midPoint))\n            result.push(wholeArray.slice(midPoint))\n        }\n        return result;\n    }\n    \n    function merge(arr1, arr2){\n        const result = [];\n        let leftPointer = 0;\n        let rightPointer = 0;\n        while (leftPointer < arr1.length && rightPointer < arr2.length){\n            if (arr1[leftPointer] < arr2[rightPointer]){\n                result.push(arr1[leftPointer])\n                leftPointer++;\n            }\n            else {\n                result.push(arr2[rightPointer])\n                rightPointer++;\n            }\n        }\n        if (leftPointer === arr1.length){\n            for (let i = rightPointer; i<arr2.length; i++){\n                result.push(arr2[i])\n            }\n        }\n        else {\n            for (let i = leftPointer; i<arr1.length; i++){\n                result.push(arr1[i])\n            }\n        }\n        return result;\n    }\n    \n    function mergeSort(wholeArray) {\n        if (wholeArray.length === 0 || wholeArray.length === 1) {\n            return wholeArray;\n        }\n        else {\n            const [first, second] = split(wholeArray)\n            return merge(\n                mergeSort(first),\n                mergeSort(second)\n            )\n        }\n    }\n    const array = [10,9,8,7,6,5,4,3,2,1]\n    mergeSort(array)\n    ",
    "binarySearch": "function binarySearch(array, target) {\n        let left = 0;\n        let right = array.length - 1\n        while (left <= right) {\n            let middle = Math.floor((right + left) / 2)\n            if (array[middle] < target) {\n                left = middle + 1\n            } else if (array[middle] > target) {\n                right = middle - 1\n            } else {\n                return middle\n            }\n        }\n        return -1\n    }\n    binarySearch([1,2,3,4,5,6,7,8,9,10], 7)\n    ",
    "threeLargest": "function findThreeLargestNumbers(array) {\n        const nums = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]\n        for (let i = 0; i < array.length; i++) {\n            let num = array[i]\n            let j = nums.length - 1\n            while (j >= 0) {\n                if (num > nums[j]) {\n                    let temp = nums[j]\n                    nums[j] = num\n                    num = temp\n                }\n                j--\n            }\n        }\n        return nums\n    }\n    findThreeLargestNumbers([100,101, 1000, 10000, 1000000])\n    ",
    "fibonacci": "function getNthFib(n, cache = {}) {\n        // Write your code here.\n        if (n === 1) return 0;\n        if (n === 2) return 1;\n        if (n in cache) return cache[n]\n        cache[n] = getNthFib(n - 1, cache) + getNthFib(n - 2, cache)\n        return cache[n]\n    }\n    getNthFib(10)\n    ",
    "threeNumberSum": "function threeNumberSum(array, targetSum) {\n        array = array.sort((a, b) => a > b)\n        const triplets = []\n        for (let i = 0; i < array.length - 1; i++) {\n            let num1 = array[i]\n            let diff = targetSum - num1\n            const hash = {}\n            for (let j = array.length - 1; j > i; j--) {\n                let num = array[j]\n                if (typeof hash[num] === 'number') {\n                    const triplet = [num1, num, hash[num]]\n                    triplets.push(triplet)\n                }\n                if (typeof hash[diff - num] !== 'number') {\n                    hash[diff - num] = num\n                }\n            }\n        }\n        return triplets\n    }\n    threeNumberSum([1,2,3,4,5,6,7,8,9,10], 10)\n    ",
    "ceasarCypher": "function caesarCipherEncryptor(string, key) {\n        const encryptedLetters = 'abcdefghijklmnopqrstuvwxyz'.split('')\n            .reduce((acc, letter, i, self) => {\n                let idx = (i + key) % 26\n                acc[letter] = self[idx]\n                return acc\n            }, {})\n        let cipher = ''\n        for (let i = 0; i < string.length; i++) {\n            cipher += encryptedLetters[string[i]]\n        }\n        return cipher\n    }\n    caesarCipherEncryptor('hello', 1)\n    ",
    "bubbleSort": "function bubbleSort(array) {\n        let swapped = false\n        for (let i = 0; i < array.length-1; i++) {\n            if (array[i] > array[i + 1]) {\n                swap(i, i + 1, array)\n                swapped = true\n            }\n        }\n        return swapped ? bubbleSort(array) : array\n    }\n    function swap(i, j, arr) {\n        let temp = arr[i]\n        arr[i] = arr[j]\n        arr[j] = temp\n    }\n    bubbleSort([5,4,3,2,1])\n    ",
    "fourNumberSum": "function fourNumberSum(array, targetSum) {\n        const allPairSums = {}\n        const quadruplets = []\n        for (let i = 1; i < array.length; i++) {\n            for (let j = i + 1; j < array.length; j++) {\n                const currentSum = array[i] + array[j]\n                const difference = targetSum - currentSum\n                if (difference in allPairSums) {\n                    for (const pair of allPairSums[difference]) {\n                        quadruplets.push(pair.concat([array[i], array[j]]))\n                    }\n                }\n            }\n            for (let k = 0; k < i; k++) {\n                const currentSum = array[i] + array[k]\n                if (!(currentSum in allPairSums)) {\n                    allPairSums[currentSum] = [[array[k], array[i]]]\n                } else {\n                    allPairSums[currentSum].push([array[k], array[i]])\n                }\n            }\n        }\n        return quadruplets\n    }\n    fourNumberSum([1,2,3,4,5,6,7,8,9,10, 0,0,0], 10)\n    ",
    "stack": "class MinMaxStack {\n        constructor() {\n            this.mins = []\n            this.maxes = []\n            this.stack = []\n        }\n        peek() {\n            // Write your code here.\n            return this.stack[this.stack.length - 1]\n        }\n    \n        pop() {\n            // Write your code here.\n            this.mins.pop()\n            this.maxes.pop()\n            return this.stack.pop()\n        }\n    \n        push(number) {\n            // Write your code here.\n            this.stack.push(number)\n            var k = number\n            if (this.getMax() === undefined || number > this.getMax()) {\n                this.maxes.push(number)\n            } else {\n                this.maxes.push(this.getMax())\n            }\n            if (this.getMin() === undefined || number < this.getMin()) {\n                this.mins.push(number)\n            } else {\n                this.mins.push(this.getMin())\n            }\n        }\n    \n        getMin() {\n            // Write your code here.\n            return this.mins[this.mins.length - 1]\n        }\n    \n        getMax() {\n            // Write your code here.\n            return this.maxes[this.maxes.length - 1]\n        }\n    }\n    const stack = new MinMaxStack()\n    stack.push(2);\n  stack.push(0);\n  stack.push(5);\n  stack.push(4);\n  stack.push(4);\n  stack.push(11);\n    stack.push(-11);\n\n  stack.push(6);\n    \n    [stack.pop(), stack.pop(), stack.pop()]\n    ",
    "kadanes": "function kadanesAlgorithm(array) {\n          let max = -Infinity\n          let maxAtCurrent = 0\n          for(let i = 0; i < array.length; i++){\n              maxAtCurrent += array[i]\n              if(maxAtCurrent > max){\n                  max = maxAtCurrent\n              }\n              if(maxAtCurrent < 0){\n                  maxAtCurrent = 0\n              }\n          }\n          return max\n      }\n      kadanesAlgorithm([1,2,3,4,5])\n      ",
    "deepAccessor": "function access(obj){\n        return obj[obj.name * obj[obj.x]]\n    }\n        const object = {\n            name: 2,\n            x: 3,\n            '3' : 30,\n            '60': 'FOUND'\n        }\n        access(object)\n    ",
    "BST": "class BST {\n        constructor(value) {\n          this.value = value;\n          this.left = null;\n          this.right = null;\n        }\n      \n        insert(value) {\n          if (value < this.value) {\n            if (this.left === null) {\n              this.left = new BST(value);\n            } else {\n              this.left.insert(value);\n            }\n          } else {\n            if (this.right === null) {\n              this.right = new BST(value);\n            } else {\n              this.right.insert(value);\n            }\n          }\n          return this;\n        }\n      }\n\n    new BST(100).insert(5).insert(15).insert(5).insert(2).insert(1).insert(22)\n        .insert(1).insert(1).insert(3).insert(1).insert(1).insert(502).insert(55000)\n        .insert(204).insert(205).insert(207).insert(206).insert(208).insert(203);",
    "riverSizes": "function riverSizes(matrix, rivers = []) {\n\n        for (let i = 0; i < matrix.length; i++) {\n            for (let j = 0; j < matrix[i].length; j++) {\n                let riverlen = getContinuation(matrix, i, j)\n                if (riverlen) {\n                    rivers.push(riverlen)\n                }\n            }\n        }\n        return rivers\n    }\n    function getContinuation(matrix, i, j) {\n        if (matrix[i] && matrix[i][j]) {\n            let riverlen = 1\n            matrix[i][j] = null\n            riverlen += getContinuation(matrix, i + 1, j)\n            riverlen += getContinuation(matrix, i, j + 1)\n            riverlen += getContinuation(matrix, i - 1, j)\n            riverlen += getContinuation(matrix, i, j - 1)\n            return riverlen\n        }\n        return 0\n    }\n    const matrix = [\n        [1, null, null, 1, null, 1, null, null, 1, 1, 1, null],\n        [1, null, 1, null, null, 1, 1, 1, 1, null, 1, null],\n        [null, null, 1, null, 1, 1, null, 1, null, 1, 1, 1],\n        [1, null, 1, null, 1, 1, null, null, null, 1, null, null],\n        [1, null, 1, 1, null, null, null, 1, 1, 1, null, 1],\n      ]\n    const rivers = [];\n    riverSizes(matrix, rivers)",
    "inPlaceMergeSort": "\n    function merge(arr, start, mid, end) {\n        let start2 = mid + 1\n        if (arr[mid] <= arr[start2]) return\n        while (start <= mid && start2 <= end) {\n            if (arr[start] <= arr[start2]) {\n                start++\n            } else {\n                let value = arr[start2]\n                let index = start2\n                while (index !== start) {\n                    arr[index] = arr[index - 1]\n                    index--\n                }\n                arr[start] = value\n                start++\n                mid++\n                start2++\n            }\n        }\n    }\n    function mergeSort(arr, l, r) {\n        if (l < r) {\n            let m = Math.floor((l + r) / 2)\n            mergeSort(arr, l, m)\n            mergeSort(arr, m + 1, r)\n            merge(arr, l, m, r)\n        }\n        return arr\n    }\n    const array = [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]\n    mergeSort(array, 0, array.length - 1)\n    "
}